{"version":3,"file":"api-request-builder.js","sourceRoot":"","sources":["../../src/base-api/api-request-builder.ts"],"names":[],"mappings":"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","sourcesContent":["import { ApiQueryOperator } from './api-query-operator';\r\nimport { QueryOperator } from './query-operator';\r\nimport { ApiQuery } from './api-query';\r\n\r\nexport class ApiRequestBuilder {\r\n    /**\r\n     * Gets the regular expression used to parse the lambda expression. ie:  x => x.firstName === value.firstName\r\n     */\r\n    private expressionRegExp = new RegExp(/(.+[^=!><])(!={1,3}|<=|>=|>|<|={1,3})\\s*(.+);\\s*\\}/);\r\n    private expressions: Array<string> = new Array<string>();\r\n\r\n    public static readonly operators: Array<ApiQueryOperator> = [\r\n        new ApiQueryOperator(QueryOperator.equals, '=', ['==', '===']),\r\n        new ApiQueryOperator(QueryOperator.exists, 'exists', ['exists()']), // TODO: Make API support methods like  foo.field.exists()\r\n        new ApiQueryOperator(QueryOperator.notEquals, '!=', ['!=', '!==']),\r\n        new ApiQueryOperator(QueryOperator.in, '=', []),\r\n        new ApiQueryOperator(QueryOperator.notIn, '!=', []),\r\n        new ApiQueryOperator(QueryOperator.greaterThan, '>', ['>']),\r\n        new ApiQueryOperator(QueryOperator.lessThan, '<', ['<']),\r\n        new ApiQueryOperator(QueryOperator.greaterThanEqualTo, '>=', ['>=']),\r\n        new ApiQueryOperator(QueryOperator.lessThanEqualTo, '<=', ['<=']),\r\n    ];\r\n\r\n    public readonly predicates = {\r\n        or: '||',\r\n        and: '&&',\r\n        lambda: 'return ',\r\n    };\r\n    \r\n\r\n    private query: Array<ApiQuery> = new Array<ApiQuery>();\r\n\r\n    /**\r\n     * Returns an array of ApiQuery objects from the given expression and parameters.\r\n     * @param expression - string representation of the expression to build the query for.\r\n     * @param parameters - object with properties representing the parameters in the expression.\r\n     */\r\n    public buildQueryFromExpression(expression: string, parameters?: any): Array<ApiQuery> {\r\n        this.expressions = this.prepareExpression(expression.toString());\r\n        this.buildQueryPredicate(parameters);\r\n        return this.query;\r\n    }\r\n\r\n    public static getOperator(value: string): ApiQueryOperator {\r\n        return ApiRequestBuilder.operators\r\n            .find((operator) => !!operator.matches.find((match) => value === match));\r\n    }\r\n\r\n    public static getByQueryOperator(value: QueryOperator): ApiQueryOperator {\r\n        return ApiRequestBuilder.operators\r\n            .find((operator) => operator.name === value);\r\n    }\r\n\r\n    private prepareExpression(expression: string): Array<string> {\r\n        if (expression.includes(this.predicates.or)) {\r\n            // TODO@zev.butler: Implement reading operators to support and, or, etc.\r\n            throw new Error(`The operator ${this.predicates.or} (or) is not yet supported. Use && or write a custom query in the microservice.`)\r\n        }\r\n\r\n        expression = expression.slice(expression.indexOf(this.predicates.lambda) + 6);\r\n        return expression.split(this.predicates.and);\r\n    }\r\n\r\n    private buildQueryPredicate(parameters?: any): void {\r\n        if (!this.expressions) {\r\n            throw new Error('No expressions were found to build predicates from.');\r\n        }\r\n\r\n        for (let predicate of this.expressions) {\r\n            const predicateMatch = this.expressionRegExp.exec(predicate);\r\n\r\n            if (!predicateMatch || predicateMatch.length < 3) {\r\n                throw new Error(`Error in specified expression on: ${predicate}`);\r\n            }\r\n\r\n            const name = this.parsePropertyName(predicateMatch[1]);\r\n            const apiQueryOperator = this.parseOperator(predicateMatch[2]);\r\n            const parameterName = this.parsePropertyName(predicateMatch[3]);\r\n            const value = this.checkValueType(parameters, parameterName);\r\n\r\n            if (value) {\r\n                const query = new ApiQuery({\r\n                    name,\r\n                    value,\r\n                    apiQueryOperator\r\n                });\r\n                this.query.push(query);\r\n            }\r\n        }\r\n    }\r\n\r\n    private checkValueType(parameters: any, parameterName: any): string {\r\n        let value;\r\n\r\n        if (parameterName.includes('.')) {\r\n            const values = parameterName.split('.');\r\n\r\n            let recursionValue = parameters;\r\n            for (let propertyName of values) {\r\n                recursionValue = recursionValue[propertyName];\r\n            }\r\n            value = recursionValue;\r\n        } else {\r\n            value = parameters[parameterName];\r\n        }\r\n\r\n        if (value instanceof Date) {\r\n            return (value as Date).toLocaleString();\r\n        }\r\n        return value;\r\n    }\r\n    \r\n    private parseOperator(providedOperator: string): ApiQueryOperator {\r\n        const matchedOperator = ApiRequestBuilder.getOperator(providedOperator);\r\n\r\n        if (!matchedOperator) {\r\n            throw new Error(`The Operator provided '${providedOperator}' is invalid or not supported.`);\r\n        }\r\n\r\n        return matchedOperator;\r\n    }\r\n\r\n    private parsePropertyName(value: string): string {\r\n        return value.slice(value.indexOf('.') + 1).trim();\r\n    }\r\n}"]}